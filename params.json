{"name":"Hambok-mentoring-flask","tagline":"hambok-mentoring-flask","body":"# 수열이의 햄볶한 멘토링 - Flask\r\n\r\n## 1. Flask 기본 세팅\r\n\r\n### 1-1. 가상환경(virtualenv) 세팅\r\n\r\n작업중인 디렉토리에서 `virtualenv venv` 명령어를 입력해서 `venv` 폴더를 가상환경 설정폴더로 지정한다.\r\n\r\n```\r\n$ virtualenv venv\r\nNew python executable in venv/bin/python\r\nInstalling setuptools............done.\r\nInstalling pip...............done.\r\n```\r\n\r\n가상환경 세팅이 완료되면 `venv` 폴더에 가상환경 관련 파일들이 담겨지게 된다.\r\n\r\n현재 디렉토리의 가상환경으로 활성화시키려면 `. venv/bin/activate` 명령어를 입력하면 된다.\r\n\r\n```\r\n$ . venv/bin/activate\r\n(venv)$\r\n```\r\n\r\n가상환경이 활성화되어있으면 쉘에 `(venv)`가 표시된다. 가상환경을 비활성화시키려면 `deactivate` 명령어를 입력하면 된다.\r\n\r\n```\r\n(venv)$ deactivate\r\n$\r\n```\r\n\r\n\r\n\r\n### 1-2. Flask 설치하기\r\n\r\nFlask는 `pip` 명령어로 쉽게 설치할 수 있다. 가상환경이 활성화된 상태에서 `pip` 명령어를 통해 설치한 패키지들은 가상환경 세팅폴더로 지정된 `./venv/lib/python2.7/site-packages/` 디렉토리에 저장된다.\r\n\r\n```\r\n(venv)$ pip install flask\r\nDownloading/unpacking flask\r\n  Downloading Flask-0.10.1.tar.gz (544kB): 544kB downloaded\r\n  Running setup.py egg_info for package flask\r\n.\r\n.\r\n.\r\nSuccessfully installed flask Werkzeug Jinja2 itsdangerous markupsafe\r\nCleaning up...\r\n```\r\n\r\nFlask가 제대로 설치되었는지 여부는 `pip list` 명령어를 통해 확인할 수 있다.\r\n\r\n```\r\n(venv)$ pip list\r\nFlask (0.10.1)\r\nitsdangerous (0.23)\r\nJinja2 (2.7.1)\r\nMarkupSafe (0.18)\r\nWerkzeug (0.9.4)\r\nwsgiref (0.1.2)\r\n```\r\n\r\nFlask를 설치하면 Jinja2, Werkzeug 등 다른 패키지들도 함께 설치되는데, 이는 Flask가 해당 패키지들을 기본적으로 사용하고 있기 때문이다. [Jinja2][1]는 템플릿 엔진이고, [Werkzeug][2]는 WSGI 툴킷이다.\r\n\r\n\r\n\r\n### 1-3. Hello, World! 출력하기\r\n\r\n가장 기본적인 예제를 만들어보자. 이 예제는 [Flask 공식 웹사이트](http://flask.pocoo.org/)의 메인에도 있는 예제이다.\r\n\r\n작업환경의 루트폴더에 hello.py라는 파일을 만들어보자. 이 파일의 이름이 여러분이 만드는 Flask 애플리케이션의 이름이 될 것이다. hello.py에는 아래의 내용을 입력하면 된다.\r\n\r\n```\r\nfrom flask import Flask\r\napp = Flask(__name__)\r\n\r\n@app.route('/')\r\ndef hello():\r\n\treturn 'Hello, World!'\r\n\r\nif __name__ == '__main__':\r\n\tapp.run()\r\n```\r\n\r\n저장 후, 해당 파일을 python으로 실행해보자.\r\n\r\n```\r\n(venv)$ python hello.py\r\n * Running on http://127.0.0.1:5000/\r\n```\r\n\r\nFlask 웹서버가 로컬호스트(127.0.0.1)의 5000번 포트에서 실행되고 있다는 말이 나온다. 인터넷 브라우저를 켜서 주소창에 <http://127.0.0.1:5000>를 입력해서 들어가면 'Hello, World!'라는 텍스트가 보일 것이다. 실행중인 애플리케이션을 종료하려면 `Ctrl`키와 `C` 키를 함께 누르면 된다.\r\n\r\n\r\n#### Host와 Port 직접 설정하기\r\n\r\nhost의 기본값은 '127.0.0.1'이고, port의 기본값은 5000이다. 만약 로컬환경이 아니라면, `app.run()` 함수의 인자로 host와 port를 직접 넣어주면 된다.\r\n\r\n```\r\napp.run(host='0.0.0.0', port=8080)\r\n```\r\n\r\n\r\n#### Debug Mode로 Flask 실행하기\r\n\r\n`app.run()` 함수에 `debug=True` 옵션을 주면 디버그모드로 Flask를 실행할 수 있다. 디버그모드로 실행할 경우 메모리를 많이 먹게 되고 성능이 저하되므로 런칭시에는 Debug 옵션을 빼주도록 하자.\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n## 2. Flask 익히기\r\n\r\n### 2-1. Route\r\n\r\nFlask에서는 매우 직관적인 URL Routing을 지원한다. 첫 번째 Hello World 예제에서도 볼 수 있듯, `@app.route` 데코레이터(Decorator)로 함수를 지정하면, 그 함수에서 리턴한 결과가 실제로 클라이언트로 전송된다.\r\n\r\n그럼, 작성한 코드를 아래와 같이 변경해보자.\r\n\r\n```\r\n@app.route('/')\r\ndef index():\r\n\treturn 'It Works!'\r\n\t\r\n@app.route('/hello')\r\ndef hello():\r\n\treturn 'Hello, World!'\r\n```\r\n\r\n그리고, 인터넷 브라우저에서 <http://127.0.0.1:5000>과 <http://127.0.0.1:5000/hello>에 접속해보자. 각각 'It Works!'와 'Hello, World!'가 보이는 것을 확인할 수 있다.\r\n\r\n이번에는 동적 URL을 다루기 위해 아래의 코드를 추가시켜보자.\r\n\r\n```\r\n@app.route('/user/<username>')\r\ndef get_user(username):\r\n\treturn 'User %s' % username\r\n```\r\n\r\n인터넷 브라우저에서 <http://127.0.0.1:5000/user/xoul>로 접속해보자.'User xoul'이라는 결과를 볼 수 있다. URL을 지정해줄 때 '<'와 '>' 사이에 있는 변수가 함수의 인자로 넘어오게 된다. 변수가 여러 개라면 여러 개의 함수 인자를 선언해주면 된다.\r\n\r\n만약 변수가 정수형이라면, `int:`를 추가시켜주면 된다.\r\n\r\n```\r\n@app.route('/post/<int:post_id>')\r\ndef get_post(post_id):\r\n\treturn 'Post %d' % post_id\r\n```\r\n\r\n#### 한글 대응하기\r\n\r\n만약 username에 영문이 아닌 유니코드를 입력하게되면 Python에러가 출력될 것이다. 유니코드를 처리하지 않아서 발생하는 에러인데, hello.py의 제일 윗줄에 `# -*- coding: utf-8 -*-`을 추가시켜주면 된다.\r\n\r\n\r\n\r\n### 2-2. HTTP Method\r\n\r\nHTTP에는 여러 개의 메소드가 있는데, 그 중 가장 많이 사용되는 것들은 GET, POST, PUT, DELETE이다. GET은 정보를 가져올 때, POST는 새로운 정보를 삽입할 때, PUT은 수정, 그리고 DELETE는 정보를 삭제할 때 사용하는 것이 가장 일반적인 사용법이다.\r\n\r\nFlask에서는 각 URL별로 허용하는 메소드를 지정할 수 있고, 요청을 받은 메소드에 따라 다른 행동을 취하도록 개발할 수 있다. `@app.route` 데코레이터에서 `methods`에 메소드 리스트를 인자로 넘기면 그 함수에서는 해당 메소드만을 처리한다. 허용되지 않은 메소드로 요청을 보내면 '405 Method Not Allowed' 에러가 발생한다.\r\n\r\n```\r\n@app.route('/login', methods=['GET', 'POST'])\r\ndef login():\r\n\tif request.method == 'GET':\r\n\t\treturn 'Show login form'\r\n\r\n\telif request.method == 'POST':\r\n\t\treturn 'Do login'\r\n```\r\n\r\n\r\n\r\n\r\n[1]: [http://jinja.pocoo.org/docs/] \"Jinja2 Documentation\"\r\n[2]: [http://werkzeug.pocoo.org/docs/] \"Werkzeug Documentation\"","google":"UA-39738800-3","note":"Don't delete this file! It's used internally to help with page regeneration."}